{
    "reason": "",
    "state": "MERGED",
    "updated_on": "2016-04-21T16:03:28.627341+00:00",
    "comment_count": 2,
    "description": "This fixes a bug reported by a student working here in Edinburgh named Andrew Mackie.  A call to `parallel_objects` will fail if called after loading a `ytdata` profile dataset.  This is because this dataset type calls a `parallel_root_only` function that calls another `parallel_root_only` function, causing the mpi processes to get out of sync.  Hat tip to Andrew for isolating this bug!",
    "created_on": "2016-04-11T10:02:53.977478+00:00",
    "task_count": 0,
    "merge_commit": {
        "links": {
            "self": {
                "href": "https://api.bitbucket.org/2.0/repositories/yt_analysis/yt/commit/843a342ee510"
            }
        },
        "hash": "843a342ee510"
    },
    "title": "[BUGFIX] cannot call parallel_root_only function inside a parallel_root_only function",
    "links": {
        "diff": {
            "href": "https://api.bitbucket.org/2.0/repositories/yt_analysis/yt/pullrequests/2126/diff"
        },
        "decline": {
            "href": "https://api.bitbucket.org/2.0/repositories/yt_analysis/yt/pullrequests/2126/decline"
        },
        "self": {
            "href": "https://api.bitbucket.org/2.0/repositories/yt_analysis/yt/pullrequests/2126"
        },
        "activity": {
            "href": "https://api.bitbucket.org/2.0/repositories/yt_analysis/yt/pullrequests/2126/activity"
        },
        "merge": {
            "href": "https://api.bitbucket.org/2.0/repositories/yt_analysis/yt/pullrequests/2126/merge"
        },
        "commits": {
            "href": "https://api.bitbucket.org/2.0/repositories/yt_analysis/yt/pullrequests/2126/commits"
        },
        "statuses": {
            "href": "https://api.bitbucket.org/2.0/repositories/yt_analysis/yt/pullrequests/2126/statuses"
        },
        "approve": {
            "href": "https://api.bitbucket.org/2.0/repositories/yt_analysis/yt/pullrequests/2126/approve"
        },
        "html": {
            "href": "https://bitbucket.org/yt_analysis/yt/pull-requests/2126"
        },
        "comments": {
            "href": "https://api.bitbucket.org/2.0/repositories/yt_analysis/yt/pullrequests/2126/comments"
        }
    },
    "closed_by": {
        "links": {
            "self": {
                "href": "https://api.bitbucket.org/2.0/users/ngoldbaum"
            },
            "html": {
                "href": "https://bitbucket.org/ngoldbaum/"
            },
            "avatar": {
                "href": "https://bitbucket.org/account/ngoldbaum/avatar/32/"
            }
        },
        "type": "user",
        "display_name": "Nathan Goldbaum",
        "uuid": "{5dcd72da-6420-4a6d-9571-e75dffcac587}",
        "username": "ngoldbaum"
    },
    "id": 2126,
    "type": "pullrequest",
    "author": {
        "links": {
            "self": {
                "href": "https://api.bitbucket.org/2.0/users/brittonsmith"
            },
            "html": {
                "href": "https://bitbucket.org/brittonsmith/"
            },
            "avatar": {
                "href": "https://bitbucket.org/account/brittonsmith/avatar/32/"
            }
        },
        "type": "user",
        "display_name": "Britton Smith",
        "uuid": "{94333901-a436-4c2c-8322-8d09e387eece}",
        "username": "brittonsmith"
    },
    "source": {
        "branch": {
            "name": "yt"
        },
        "commit": {
            "links": {
                "self": {
                    "href": "https://api.bitbucket.org/2.0/repositories/brittonsmith/yt/commit/98f574019641"
                }
            },
            "hash": "98f574019641"
        },
        "repository": {
            "full_name": "brittonsmith/yt",
            "type": "repository",
            "links": {
                "self": {
                    "href": "https://api.bitbucket.org/2.0/repositories/brittonsmith/yt"
                },
                "html": {
                    "href": "https://bitbucket.org/brittonsmith/yt"
                },
                "avatar": {
                    "href": "https://bitbucket.org/brittonsmith/yt/avatar/32/"
                }
            },
            "name": "yt",
            "uuid": "{a3a98ec1-6936-4db5-8667-658e17c1eaca}"
        }
    },
    "close_source_branch": false,
    "destination": {
        "branch": {
            "name": "yt"
        },
        "commit": {
            "links": {
                "self": {
                    "href": "https://api.bitbucket.org/2.0/repositories/yt_analysis/yt/commit/248ccc5ef8b4"
                }
            },
            "hash": "248ccc5ef8b4"
        },
        "repository": {
            "full_name": "yt_analysis/yt",
            "type": "repository",
            "links": {
                "self": {
                    "href": "https://api.bitbucket.org/2.0/repositories/yt_analysis/yt"
                },
                "html": {
                    "href": "https://bitbucket.org/yt_analysis/yt"
                },
                "avatar": {
                    "href": "https://bitbucket.org/yt_analysis/yt/avatar/32/"
                }
            },
            "name": "yt",
            "uuid": "{b73cb37c-40f2-493a-aaa9-41bc8d8974cc}"
        }
    },
    "comments": [
        {
            "user": {
                "links": {
                    "self": {
                        "href": "https://api.bitbucket.org/2.0/users/ngoldbaum"
                    },
                    "html": {
                        "href": "https://bitbucket.org/ngoldbaum/"
                    },
                    "avatar": {
                        "href": "https://bitbucket.org/account/ngoldbaum/avatar/32/"
                    }
                },
                "type": "user",
                "display_name": "Nathan Goldbaum",
                "uuid": "{5dcd72da-6420-4a6d-9571-e75dffcac587}",
                "username": "ngoldbaum"
            },
            "type": "pullrequest_comment",
            "links": {
                "self": {
                    "href": "https://api.bitbucket.org/2.0/repositories/yt_analysis/yt/pullrequests/2126/comments/17177488"
                },
                "html": {
                    "href": "https://bitbucket.org/yt_analysis/yt/pull-requests/2126/_/diff#comment-17177488"
                }
            },
            "pullrequest": {
                "title": "[BUGFIX] cannot call parallel_root_only function inside a parallel_root_only function",
                "type": "pullrequest",
                "links": {
                    "self": {
                        "href": "https://api.bitbucket.org/2.0/repositories/yt_analysis/yt/pullrequests/2126"
                    },
                    "html": {
                        "href": "https://bitbucket.org/yt_analysis/yt/pull-requests/2126"
                    }
                },
                "id": 2126
            },
            "content": {
                "raw": "Is there a way we can fix this in `parallel_root_only`? Could we just make that function a wrapper around `is_root()`? I see right now it does some dancing to handle tracebacks, is all that really necessary?",
                "html": "<p>Is there a way we can fix this in <code>parallel_root_only</code>? Could we just make that function a wrapper around <code>is_root()</code>? I see right now it does some dancing to handle tracebacks, is all that really necessary?</p>",
                "markup": "markdown"
            },
            "created_on": "2016-04-13T13:43:53.262071+00:00",
            "updated_on": "2016-04-13T13:43:53.269176+00:00",
            "id": 17177488
        },
        {
            "user": {
                "links": {
                    "self": {
                        "href": "https://api.bitbucket.org/2.0/users/brittonsmith"
                    },
                    "html": {
                        "href": "https://bitbucket.org/brittonsmith/"
                    },
                    "avatar": {
                        "href": "https://bitbucket.org/account/brittonsmith/avatar/32/"
                    }
                },
                "type": "user",
                "display_name": "Britton Smith",
                "uuid": "{94333901-a436-4c2c-8322-8d09e387eece}",
                "username": "brittonsmith"
            },
            "type": "pullrequest_comment",
            "links": {
                "self": {
                    "href": "https://api.bitbucket.org/2.0/repositories/yt_analysis/yt/pullrequests/2126/comments/17179845"
                },
                "html": {
                    "href": "https://bitbucket.org/yt_analysis/yt/pull-requests/2126/_/diff#comment-17179845"
                }
            },
            "parent": {
                "links": {
                    "self": {
                        "href": "https://api.bitbucket.org/2.0/repositories/yt_analysis/yt/pullrequests/2126/comments/17177488"
                    },
                    "html": {
                        "href": "https://bitbucket.org/yt_analysis/yt/pull-requests/2126/_/diff#comment-17177488"
                    }
                },
                "id": 17177488
            },
            "pullrequest": {
                "title": "[BUGFIX] cannot call parallel_root_only function inside a parallel_root_only function",
                "type": "pullrequest",
                "links": {
                    "self": {
                        "href": "https://api.bitbucket.org/2.0/repositories/yt_analysis/yt/pullrequests/2126"
                    },
                    "html": {
                        "href": "https://bitbucket.org/yt_analysis/yt/pull-requests/2126"
                    }
                },
                "id": 2126
            },
            "content": {
                "raw": "I think the thing the `parallel_root_only` does that can't be circumvented is setting up a barrier for all of the non-root processes to wait until the root is finished.  In that situation, if you called a `parallel_root_only` inside another `parallel_root_only` function, you always end up with misaligned barriers since the non-roots never even get into the second one.  I think if you want the non-roots to wait (which I believe we do), there is no other way.",
                "html": "<p>I think the thing the <code>parallel_root_only</code> does that can't be circumvented is setting up a barrier for all of the non-root processes to wait until the root is finished.  In that situation, if you called a <code>parallel_root_only</code> inside another <code>parallel_root_only</code> function, you always end up with misaligned barriers since the non-roots never even get into the second one.  I think if you want the non-roots to wait (which I believe we do), there is no other way.</p>",
                "markup": "markdown"
            },
            "created_on": "2016-04-13T14:14:14.225433+00:00",
            "updated_on": "2016-04-13T14:14:14.230835+00:00",
            "id": 17179845
        }
    ]
}